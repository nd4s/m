<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–û—Ñ–ª–∞–π–Ω-–ö–∞—Ä—Ç–∏</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --accent-color: #3498db;
            --text-color: #ecf0f1;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --warning-color: #f1c40f;
            --toolbar-height: 60px;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; 
            background: #e5e3df;
            overflow: hidden;
        }
        
        /* MODERN TOOLBAR */
        #controls { 
            height: var(--toolbar-height);
            background: var(--bg-color); 
            display: flex; 
            align-items: center; 
            padding: 0 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3); 
            z-index: 2000;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            gap: 10px;
            scrollbar-width: none;
        }
        #controls::-webkit-scrollbar { display: none; }

        .group { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            padding-right: 12px; 
            border-right: 1px solid #4a5f70;
            height: 40px;
        }
        .group:last-child { border-right: none; margin-left: auto; }
        
        h1 { 
            font-size: 20px; margin: 0; color: #fff; margin-right: 5px; 
            display: flex; align-items: center;
        }

        /* BUTTONS */
        button, .file-btn-label { 
            height: 36px;
            min-width: 36px;
            padding: 0 10px; 
            cursor: pointer; 
            border-radius: 6px; 
            border: none; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: white;
            font-weight: 500;
        }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }

        #btn-download { background: var(--accent-color); }
        #btn-save-file { background: #7f8c8d; display: none; }
        #btn-loc { background: #1abc9c; }
        #btn-img-upload { background: #9b59b6; }
        #btn-img-close { background: var(--danger-color); display: none; }
        #btn-route { background: #e67e22; }
        #btn-search { background: var(--warning-color); color: #333; border-radius: 0 6px 6px 0; }
        #btn-clear { background: var(--danger-color); font-size: 14px;}
        #btn-import { background: var(--success-color); }

        .routing-active { 
            background: white !important; 
            color: #e67e22 !important; 
            border: 2px solid #e67e22 !important; 
            box-shadow: 0 0 8px #e67e22 inset;
        }

        /* SEARCH INPUT */
        .search-wrapper { position: relative; display: flex; align-items: center; }
        #search-input { 
            height: 36px; 
            padding: 0 10px; 
            border-radius: 6px 0 0 6px; 
            border: none; 
            width: 140px; 
            outline: none;
            background: #fff;
            color: #333;
            transition: width 0.3s;
        }
        #search-input:focus { width: 180px; }

        #search-suggestions {
            position: absolute;
            top: 40px; left: 0; width: 220px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 3000;
            max-height: 60vh;
            overflow-y: auto;
            display: none;
            text-align: left;
            white-space: normal;
        }
        .suggestion-item { padding: 10px; border-bottom: 1px solid #eee; color: #333; cursor: pointer; font-size: 13px; line-height: 1.4; }
        .suggestion-item:hover { background: #f1f2f6; }

        /* TOGGLE SWITCH */
        .toggle-wrapper { position: relative; display: flex; align-items: center; }
        .toggle-checkbox { display: none; }
        .toggle-btn {
            background: #27ae60;
            color: white;
            padding: 0 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
            height: 32px;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            white-space: nowrap;
        }
        .toggle-checkbox:checked + .toggle-btn { background: #c0392b; }
        .status-icon::before { content: 'üåê'; }
        .toggle-checkbox:checked + .toggle-btn .status-icon::before { content: 'üìµ'; }

        /* STATUS BAR */
        #status-bar { 
            position: absolute; 
            bottom: 25px; left: 50%; 
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75); 
            color: white; 
            padding: 6px 15px; 
            border-radius: 20px;
            font-size: 11px; 
            font-family: monospace; 
            z-index: 1000;
            pointer-events: none;
            white-space: nowrap;
            backdrop-filter: blur(2px);
            transition: opacity 0.5s;
        }

        #map { flex-grow: 1; background: #e5e3df; cursor: crosshair; width: 100%; z-index: 1; }
        
        /* If custom image is loaded, background should be dark to focus on image */
        body.custom-mode #map { background: #111; }
        .cached-tile { outline: 1px solid rgba(46, 204, 113, 0.3); filter: sepia(0.15); }

        @media (max-width: 600px) {
            #search-input { width: 100px; }
            #search-input:focus { width: 140px; }
            h1 span { display: none; }
            .group { padding-right: 8px; gap: 5px; }
            button { padding: 0 8px; }
        }
    </style>
</head>
<body>

<div id="controls">
    <div class="group" style="border:none; padding-right:5px;">
        <h1 title="–û—Ñ–ª–∞–π–Ω-–º–∞–ø–∏">üó∫Ô∏è<span>–ú–∞–ø–∞</span></h1>
    </div>

    <div class="group">
        <div class="toggle-wrapper">
            <input type="checkbox" id="mode-toggle" class="toggle-checkbox" onchange="toggleMode()">
            <label for="mode-toggle" class="toggle-btn" title="–ü–µ—Ä–µ–º–∏–∫–∞—á –û–Ω–ª–∞–π–Ω/–û—Ñ–ª–∞–π–Ω">
                <span class="status-icon"></span>
                <span id="mode-text">–ê–≤—Ç–æ</span>
            </label>
        </div>
    </div>

    <div class="group">
        <div class="search-wrapper">
            <input type="text" id="search-input" placeholder="–ü–æ—à—É–∫..." 
                   oninput="handleSearchInput(this)" 
                   onkeypress="handleSearchEnter(event)"
                   autocomplete="off">
            <button id="btn-search" onclick="doSearch()" title="–ü–æ—à—É–∫">üîç</button>
            <div id="search-suggestions"></div>
        </div>
    </div>

    <div class="group">
        <button id="btn-loc" onclick="checkLocation()" title="–ú–æ—è –ª–æ–∫–∞—Ü—ñ—è">üéØ</button>
        <button id="btn-route" onclick="toggleRouteMode()" title="–°—Ç–≤–æ—Ä–∏—Ç–∏ –º–∞—Ä—à—Ä—É—Ç">üõ£Ô∏è</button>
    </div>

    <div class="group">
        <input type="file" id="img-input" accept="image/*" style="display: none;" onchange="handleImageUpload(this)">
        <button id="btn-img-upload" onclick="document.getElementById('img-input').click()" title="–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–æ—Ç–æ-–º–∞–ø—É">üñºÔ∏è</button>
        <button id="btn-img-close" onclick="closeImageMap()" title="–ó–∞–∫—Ä–∏—Ç–∏ —Ñ–æ—Ç–æ-–º–∞–ø—É">‚úï</button>
    </div>

    <div class="group">
        <button id="btn-download" onclick="startDownload()" title="–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –æ–±–ª–∞—Å—Ç—å">üì•</button>
        <button id="btn-save-file" onclick="exportLastDownload()" title="–ó–±–µ—Ä–µ–≥—Ç–∏ .mapzip">üíæ</button>
    </div>

    <div class="group" style="margin-left: auto; border:none; padding-right:0;">
        <input type="file" id="zip-input" accept=".mapzip,.zip" style="display: none;" onchange="importMapArchive(this)">
        <button id="btn-import" onclick="document.getElementById('zip-input').click()" title="–Ü–º–ø–æ—Ä—Ç">üìÇ</button>
        <button id="btn-clear" onclick="clearData()" title="–û—á–∏—Å—Ç–∏—Ç–∏">üóëÔ∏è</button>
    </div>
</div>

<div id="map"></div>
<div id="status-bar">–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞</div>

<script>
    const CDN_CSS = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
    const CDN_JS = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
    const CDN_JSZIP = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    
    let map = null, db = null, isOfflineOnly = false, tileLayer = null, searchDebounce = null;
    let noConnectionStart = 0, customMapImage = null, customMapBounds = null, isCustomImageMode = false;
    let isRoutingMode = false, routePoints = [], routeLayer = null, routeMarkers = [];
    let lastDownloadedBounds = null; 

    async function boot() {
        updateStatus("–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –±—ñ–±–ª—ñ–æ—Ç–µ–∫...");
        let css = localStorage.getItem('lib_css'), js = localStorage.getItem('lib_js'), jszip = localStorage.getItem('lib_jszip');
        if (!css || !js || !jszip) {
            updateStatus("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...");
            try {
                const [cssRes, jsRes, zipRes] = await Promise.all([fetch(CDN_CSS), fetch(CDN_JS), fetch(CDN_JSZIP)]);
                css = await cssRes.text(); js = await jsRes.text(); jszip = await zipRes.text();
                localStorage.setItem('lib_css', css); localStorage.setItem('lib_js', js); localStorage.setItem('lib_jszip', jszip);
            } catch (e) { updateStatus("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫."); return; }
        }
        const styleTag = document.createElement('style'); styleTag.textContent = css; document.head.appendChild(styleTag);
        const zipTag = document.createElement('script'); zipTag.textContent = jszip; document.body.appendChild(zipTag);
        const scriptTag = document.createElement('script'); scriptTag.textContent = js; document.body.appendChild(scriptTag);
        setTimeout(initApp, 200);
        document.addEventListener('click', e => { if (!e.target.closest('#search-suggestions') && e.target.id !== 'search-input') document.getElementById('search-suggestions').style.display = 'none'; });
        initAutoOfflineProtection();
    }

    function initApp() {
        if (typeof L === 'undefined' || typeof JSZip === 'undefined') return setTimeout(initApp, 100);
        const request = indexedDB.open("StrictOfflineDB", 14);
        request.onupgradeneeded = e => {
            db = e.target.result;
            if (!db.objectStoreNames.contains("tiles")) db.createObjectStore("tiles", { keyPath: "key" });
            if (!db.objectStoreNames.contains("search_cache")) db.createObjectStore("search_cache", { keyPath: "query" });
            if (!db.objectStoreNames.contains("routes_cache")) db.createObjectStore("routes_cache", { keyPath: "key" });
        };
        request.onsuccess = e => { db = e.target.result; updateStatus("–ì–æ—Ç–æ–≤–æ. –û–Ω–ª–∞–π–Ω."); initMap(); };
    }

    function initMap() {
        map = L.map('map', { zoomControl: false }).setView([50.4501, 30.5234], 13);
        L.control.zoom({ position: 'bottomright' }).addTo(map);
        map.on('click', onMapClick);
        
        L.TileLayer.Smart = L.TileLayer.extend({
            createTile: function(coords, done) {
                const tile = document.createElement('img');
                const key = `${coords.z}_${coords.x}_${coords.y}`;

                L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
                L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));

                // 1. CUSTOM IMAGE MODE (High Priority)
                if (isCustomImageMode && customMapImage && customMapBounds) {
                    const canvasUrl = getTileFromCustomImage(coords);
                    if (canvasUrl) {
                        tile.src = canvasUrl;
                        return tile;
                    } else {
                        // Empty tile if outside image bounds in custom mode
                        tile.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
                        return tile;
                    }
                }

                // 2. STANDARD DB/ONLINE MODE
                const tx = db.transaction("tiles", "readonly");
                tx.objectStore("tiles").get(key).onsuccess = e => {
                    if (e.target.result?.blob) { 
                        tile.src = URL.createObjectURL(e.target.result.blob); 
                        tile.classList.add('cached-tile'); 
                    } else if (isOfflineOnly) {
                        tile.src = "data:image/svg+xml;base64," + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256"><rect width="256" height="256" fill="#222"/><text x="128" y="128" font-family="sans-serif" font-size="20" fill="#555" text-anchor="middle">–û–§–õ–ê–ô–ù</text></svg>');
                    } else {
                        tile.src = `https://tile.openstreetmap.org/${coords.z}/${coords.x}/${coords.y}.png`;
                    }
                };
                return tile;
            }
        });
        tileLayer = new L.TileLayer.Smart(null, { maxZoom: 18 }).addTo(map);
    }

    // --- CUSTOM IMAGE TILING LOGIC ---
    function getTileFromCustomImage(coords) {
        // Calculate the LatLng bounds of the requested tile
        const tileNw = map.unproject(L.point(coords.x * 256, coords.y * 256), coords.z);
        const tileSe = map.unproject(L.point((coords.x + 1) * 256, (coords.y + 1) * 256), coords.z);
        const tileBounds = L.latLngBounds(tileNw, tileSe);

        // Check if this tile intersects with the custom image
        if (!customMapBounds.intersects(tileBounds)) return null;

        // Create a canvas to draw the slice
        const canvas = document.createElement('canvas');
        canvas.width = 256; 
        canvas.height = 256;
        const ctx = canvas.getContext('2d');

        // Logic: Map the CustomImage bounds to Pixel coordinates at the *current* zoom level
        const mapZoom = coords.z;
        
        // Pixel coordinates of the Custom Image's Top-Left and Bottom-Right at this zoom
        const imgNwPt = map.project(customMapBounds.getNorthWest(), mapZoom);
        const imgSePt = map.project(customMapBounds.getSouthEast(), mapZoom);
        
        // Size of the custom image in "map pixels" at this zoom level
        const imgW = imgSePt.x - imgNwPt.x;
        const imgH = imgSePt.y - imgNwPt.y;

        // Pixel coordinates of the requested Tile's Top-Left
        const tileNwPt = L.point(coords.x * 256, coords.y * 256);

        // Calculate offset: where is the image Top-Left relative to the Tile Top-Left?
        const offsetX = imgNwPt.x - tileNwPt.x;
        const offsetY = imgNwPt.y - tileNwPt.y;

        // Draw!
        ctx.drawImage(customMapImage, offsetX, offsetY, imgW, imgH);

        return canvas.toDataURL();
    }

    function handleImageUpload(i) { 
        if (i.files?.[0]) { 
            const r = new FileReader(); 
            r.onload = e => { 
                const img = new Image(); 
                img.onload = () => { 
                    customMapImage = img; 
                    
                    // Calculate bounds to preserve aspect ratio within current view
                    const c = map.getCenter();
                    const z = map.getZoom();
                    const viewSize = map.getSize(); // Pixels on screen
                    
                    // Scale image to fit 90% of screen
                    const scaleFactor = Math.min(viewSize.x / img.naturalWidth, viewSize.y / img.naturalHeight) * 0.9;
                    
                    // Calculate dimensions in map pixels
                    const scaledW = img.naturalWidth * scaleFactor;
                    const scaledH = img.naturalHeight * scaleFactor;
                    
                    // Center point in pixel coords
                    const centerPt = map.project(c, z);
                    
                    // Calculate corners
                    const nwPt = L.point(centerPt.x - scaledW/2, centerPt.y - scaledH/2);
                    const sePt = L.point(centerPt.x + scaledW/2, centerPt.y + scaledH/2);
                    
                    customMapBounds = L.latLngBounds(
                        map.unproject(nwPt, z),
                        map.unproject(sePt, z)
                    );

                    isCustomImageMode = true; 
                    
                    // --- CLEAN ROUTE OVERLAYS ---
                    // Since custom image covers the map, old routes are irrelevant.
                    if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
                    routeMarkers.forEach(m => map.removeLayer(m));
                    routeMarkers = [];
                    routePoints = [];
                    if (isRoutingMode) {
                        isRoutingMode = false;
                        document.getElementById('btn-route').classList.remove('routing-active');
                    }
                    // ---------------------------

                    // UI Updates
                    document.getElementById('btn-img-upload').style.display = 'none'; 
                    document.getElementById('btn-img-close').style.display = 'flex'; 
                    document.body.classList.add('custom-mode');
                    
                    // Force Offline Switch (Visual & Logic)
                    document.getElementById('mode-toggle').checked = true;
                    document.getElementById('mode-text').innerText = "–§–æ—Ç–æ";
                    isOfflineOnly = true;

                    updateStatus("–§–æ—Ç–æ-–º–∞–ø—É –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ");
                    
                    // Fit map to image
                    map.fitBounds(customMapBounds);
                    tileLayer.redraw(); 
                }; 
                img.src = e.target.result; 
            }; 
            r.readAsDataURL(i.files[0]); 
        } 
    }

    function closeImageMap() { 
        isCustomImageMode = false; 
        customMapImage = null;
        document.getElementById('btn-img-upload').style.display = 'flex'; 
        document.getElementById('btn-img-close').style.display = 'none'; 
        document.body.classList.remove('custom-mode');
        
        // Reset Toggle Text (Keep it checked/offline if user wants, but reset text)
        document.getElementById('mode-text').innerText = "–û—Ñ–ª–∞–π–Ω";
        
        updateStatus("–ó–≤–∏—á–∞–π–Ω—É –º–∞–ø—É –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ");
        tileLayer.redraw(); 
    }
    // --- END CUSTOM IMAGE LOGIC ---

    function initAutoOfflineProtection() {
        setInterval(async () => {
            if (isOfflineOnly) { noConnectionStart = 0; return; }
            let isConnected = navigator.onLine;
            if (isConnected) {
                try {
                    const ctrl = new AbortController(); setTimeout(() => ctrl.abort(), 2000);
                    await fetch('https://tile.openstreetmap.org/0/0/0.png', { method: 'HEAD', signal: ctrl.signal, cache: 'no-store' });
                } catch (e) { isConnected = false; }
            }
            if (!isConnected) {
                if (noConnectionStart === 0) noConnectionStart = Date.now();
                else if (Date.now() - noConnectionStart > 15000) {
                    document.getElementById('mode-toggle').checked = true; toggleMode(); noConnectionStart = 0;
                    alert("–Ü–Ω—Ç–µ—Ä–Ω–µ—Ç –≤—ñ–¥—Å—É—Ç–Ω—ñ–π >15—Å. –ü–µ—Ä–µ—Ö—ñ–¥ –≤ –æ—Ñ–ª–∞–π–Ω.");
                }
            } else noConnectionStart = 0;
        }, 5000);
    }

    async function startDownload() {
        const btn = document.getElementById('btn-download'), b = map.getBounds();
        document.getElementById('btn-save-file').style.display = 'none';
        let queue = [];
        for (let z = 0; z <= 18; z++) {
             const y1 = lat2tile(b.getNorth(), z), y2 = lat2tile(b.getSouth(), z), x1 = long2tile(b.getWest(), z), x2 = long2tile(b.getEast(), z);
             for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) queue.push({z, x, y});
        }
        const total = queue.length;
        let asArchive = false;
        if (total > 5000) { if (!confirm(`–ó–æ–Ω–∞ –º—ñ—Å—Ç–∏—Ç—å ${total} —Ç–∞–π–ª—ñ–≤. –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —è–∫ –∞—Ä—Ö—ñ–≤ (.mapzip)?`)) return; asArchive = true; }
        
        btn.disabled = true;
        const metadataCount = await downloadPlacesMetadata(b);
        const zip = asArchive ? new JSZip() : null;
        let saved = 0; const startTime = Date.now();

        for (let i = 0; i < total; i++) {
            const item = queue[i], elapsed = Date.now() - startTime;
            const timeStr = i > 5 ? `~${Math.ceil(((elapsed/(i+1))*(total-i))/60000)} —Ö–≤` : "...";
            updateStatus(`–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è ${i+1}/${total} (${timeStr})...`);
            try {
                const r = await fetch(`https://tile.openstreetmap.org/${item.z}/${item.x}/${item.y}.png`);
                if(r.ok) {
                    const blob = await r.blob(), key = `${item.z}_${item.x}_${item.y}`;
                    if (asArchive) zip.file(`${key}.png`, blob);
                    else await db.transaction("tiles", "readwrite").objectStore("tiles").put({ key, blob });
                    saved++;
                }
            } catch(e) {}
            if (i % 25 === 0) await new Promise(r => setTimeout(r, 10));
        }

        if (asArchive) {
            updateStatus("–ê—Ä—Ö—ñ–≤–∞—Ü—ñ—è...");
            const searchData = await getSearchDataInBounds(b);
            zip.file("metadata.json", JSON.stringify(searchData));
            const content = await zip.generateAsync({type:"blob"});
            saveBlob(content, `map_${Date.now()}.mapzip`);
            updateStatus("–ê—Ä—Ö—ñ–≤ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ.");
        } else {
            lastDownloadedBounds = b;
            document.getElementById('btn-save-file').style.display = 'flex';
            updateStatus(`–ì–æ—Ç–æ–≤–æ! ${saved} —Ç–∞–π–ª—ñ–≤ –∑–±–µ—Ä–µ–∂–µ–Ω–æ.`);
        }
        btn.disabled = false; tileLayer.redraw();
    }

    async function exportLastDownload() {
        if (!lastDownloadedBounds) return;
        updateStatus("–ï–∫—Å–ø–æ—Ä—Ç...");
        const zip = new JSZip(), b = lastDownloadedBounds;
        const tx = db.transaction("tiles", "readonly"), store = tx.objectStore("tiles");
        let count = 0;
        for (let z = 0; z <= 18; z++) {
            const y1 = lat2tile(b.getNorth(), z), y2 = lat2tile(b.getSouth(), z), x1 = long2tile(b.getWest(), z), x2 = long2tile(b.getEast(), z);
            for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) {
                const key = `${z}_${x}_${y}`;
                const res = await new Promise(r => { store.get(key).onsuccess = e => r(e.target.result); });
                if (res?.blob) { zip.file(`${key}.png`, res.blob); count++; }
            }
        }
        const searchData = await getSearchDataInBounds(b);
        zip.file("metadata.json", JSON.stringify(searchData));
        const content = await zip.generateAsync({type:"blob"});
        saveBlob(content, `export_${count}_tiles.mapzip`);
        updateStatus("–ï–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!");
    }

    async function importMapArchive(input) {
        if (!input.files?.[0]) return;
        updateStatus("–Ü–º–ø–æ—Ä—Ç...");
        try {
            const zip = await JSZip.loadAsync(input.files[0]);
            let count = 0;
            for (const filename of Object.keys(zip.files)) {
                if (filename.endsWith(".png")) {
                    const blob = await zip.files[filename].async("blob");
                    await db.transaction("tiles", "readwrite").objectStore("tiles").put({ key: filename.replace(".png", ""), blob });
                    count++;
                } else if (filename === "metadata.json") {
                    const data = JSON.parse(await zip.files[filename].async("string"));
                    const tx = db.transaction("search_cache", "readwrite");
                    data.forEach(item => tx.objectStore("search_cache").put(item));
                }
                if (count % 100 === 0) updateStatus(`–Ü–º–ø–æ—Ä—Ç: ${count}...`);
            }
            alert(`–Ü–º–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ ${count} —Ç–∞–π–ª—ñ–≤.`); tileLayer.redraw();
        } catch (e) { alert("–ü–æ–º–∏–ª–∫–∞ —ñ–º–ø–æ—Ä—Ç—É"); }
        input.value = "";
    }

    async function getSearchDataInBounds(bounds) {
        return new Promise(res => {
            db.transaction("search_cache", "readonly").objectStore("search_cache").getAll().onsuccess = e => {
                res(e.target.result.filter(i => bounds.contains([i.lat, i.lon])));
            };
        });
    }

    async function downloadPlacesMetadata(bounds) {
        const q = `[out:json][timeout:60];(nwr["name"](${bounds.getSouth()-0.01},${bounds.getWest()-0.01},${bounds.getNorth()+0.01},${bounds.getEast()+0.01}););out center;`;
        try {
            const r = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(q)}`);
            const d = await r.json();
            const tx = db.transaction("search_cache", "readwrite");
            d.elements.forEach(el => {
                const lat = el.lat || el.center?.lat, lon = el.lon || el.center?.lon;
                if (lat && el.tags?.name) tx.objectStore("search_cache").put({ query: el.tags.name.toLowerCase(), lat, lon, display_name: el.tags.name + " (–û—Ñ–ª–∞–π–Ω)" });
            });
            return d.elements.length;
        } catch(e) { return 0; }
    }

    function handleSearchInput(input) {
        const val = input.value.trim().toLowerCase();
        if(val.length < 2) { document.getElementById('search-suggestions').style.display = 'none'; return; }
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
            db.transaction("search_cache", "readonly").objectStore("search_cache").getAll().onsuccess = e => {
                const matches = e.target.result.filter(x => x.query.includes(val)).slice(0, 10);
                const list = document.getElementById('search-suggestions');
                list.innerHTML = '';
                if (!matches.length) { list.style.display = 'none'; return; }
                matches.forEach(item => {
                    const div = document.createElement('div'); div.className = 'suggestion-item'; div.innerHTML = `üìç ${item.display_name}`;
                    div.onclick = () => { document.getElementById('search-input').value = item.display_name.split('(')[0].trim(); moveToLocation(item.lat, item.lon, item.display_name); list.style.display = 'none'; };
                    list.appendChild(div);
                });
                list.style.display = 'block';
            };
        }, 300);
    }

    function doSearch() {
        const q = document.getElementById('search-input').value.trim().toLowerCase();
        db.transaction("search_cache", "readonly").objectStore("search_cache").get(q).onsuccess = e => {
            if (e.target.result) moveToLocation(e.target.result.lat, e.target.result.lon, e.target.result.display_name);
            else if (!isOfflineOnly) searchOnline(q);
        };
    }

    async function searchOnline(query) {
        const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
        const d = await r.json();
        if (d?.[0]) {
            moveToLocation(d[0].lat, d[0].lon, d[0].display_name);
            db.transaction("search_cache", "readwrite").objectStore("search_cache").put({ query, lat: d[0].lat, lon: d[0].lon, display_name: d[0].display_name });
        }
    }

    function toggleRouteMode() {
        isRoutingMode = !isRoutingMode; const btn = document.getElementById('btn-route');
        if (isRoutingMode) { btn.classList.add('routing-active'); routeMarkers.forEach(m => map.removeLayer(m)); routePoints = []; updateStatus("–û–±–µ—Ä—ñ—Ç—å 2 —Ç–æ—á–∫–∏ –Ω–∞ –º–∞–ø—ñ"); }
        else { btn.classList.remove('routing-active'); updateStatus("–†–µ–∂–∏–º –º–∞—Ä—à—Ä—É—Ç—É –≤–∏–º–∫–Ω–µ–Ω–æ"); }
    }

    function onMapClick(e) {
        if (!isRoutingMode) return;
        routePoints.push(e.latlng); routeMarkers.push(L.marker(e.latlng).addTo(map));
        if (routePoints.length === 2) { calculateRoute(routePoints[0], routePoints[1]); toggleRouteMode(); }
    }

    async function calculateRoute(s, end) {
        const key = `${s.lat.toFixed(3)},${s.lng.toFixed(3)}_${end.lat.toFixed(3)},${end.lng.toFixed(3)}`;
        db.transaction("routes_cache", "readonly").objectStore("routes_cache").get(key).onsuccess = async e => {
            if (e.target.result) drawRoute(e.target.result.geometry, "–û—Ñ–ª–∞–π–Ω");
            else if (!isOfflineOnly) {
                updateStatus("–ü–æ—à—É–∫ –º–∞—Ä—à—Ä—É—Ç—É –æ–Ω–ª–∞–π–Ω...");
                try {
                    const r = await fetch(`https://router.project-osrm.org/route/v1/driving/${s.lng},${s.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`);
                    const d = await r.json();
                    if (d.routes?.[0]) {
                        const geo = d.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
                        drawRoute(geo, `${(d.routes[0].distance/1000).toFixed(1)} –∫–º`);
                        db.transaction("routes_cache", "readwrite").objectStore("routes_cache").put({ key, geometry: geo });
                    }
                } catch(e) { updateStatus("–ü–æ–º–∏–ª–∫–∞ –º–∞—Ä—à—Ä—É—Ç—É."); }
            } else { updateStatus("–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –∑–±–µ—Ä–µ–∂–µ–Ω–æ."); }
        };
    }

    function drawRoute(g, l) { if (routeLayer) map.removeLayer(routeLayer); routeLayer = L.polyline(g, { color: 'blue', weight: 5 }).addTo(map); map.fitBounds(routeLayer.getBounds()); updateStatus(`–ú–∞—Ä—à—Ä—É—Ç: ${l}`); }
    
    function toggleMode() { 
        // Only allow manual toggle if NOT in custom image mode
        if (isCustomImageMode) {
            updateStatus("–°–ø–µ—Ä—à—É –∑–∞–∫—Ä–∏–π—Ç–µ —Ñ–æ—Ç–æ-–º–∞–ø—É");
            document.getElementById('mode-toggle').checked = true; // force keep checked
            return;
        }
        isOfflineOnly = document.getElementById('mode-toggle').checked; 
        document.getElementById('btn-download').disabled = isOfflineOnly; 
        document.getElementById('mode-text').innerText = isOfflineOnly ? "–û—Ñ–ª–∞–π–Ω" : "–ê–≤—Ç–æ";
        tileLayer.redraw(); 
    }
    
    function checkLocation() { navigator.geolocation.getCurrentPosition(p => moveToLocation(p.coords.latitude, p.coords.longitude, "–í–∏ —Ç—É—Ç")); }
    function moveToLocation(lat, lng, t) { map.setView([lat, lng], 15); L.popup().setLatLng([lat, lng]).setContent(t).openOn(map); }
    function saveBlob(b, n) { const a = document.createElement("a"); a.href = URL.createObjectURL(b); a.download = n; a.click(); }
    function clearData() { if(confirm("–û—á–∏—Å—Ç–∏—Ç–∏ –≤—Å—ñ –æ—Ñ–ª–∞–π–Ω –¥–∞–Ω—ñ?")) { db.transaction("tiles", "readwrite").objectStore("tiles").clear(); db.transaction("search_cache", "readwrite").objectStore("search_cache").clear(); location.reload(); } }
    function updateStatus(m) { 
        const sb = document.getElementById('status-bar');
        sb.innerText = m; 
        sb.style.opacity = '1';
        setTimeout(() => { sb.style.opacity = '0.7'; }, 2000);
    }
    function handleSearchEnter(e) { if(e.key === 'Enter') doSearch(); }
    function long2tile(l,z) { return Math.floor((l+180)/360*Math.pow(2,z)); }
    function lat2tile(l,z)  { return Math.floor((1-Math.log(Math.tan(l*Math.PI/180) + 1/Math.cos(l*Math.PI/180))/Math.PI)/2 *Math.pow(2,z)); }
    
    boot();
</script>
</body>
</html>
